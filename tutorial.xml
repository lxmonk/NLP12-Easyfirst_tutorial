<?xml version="1.0" encoding="utf-8"?>
<!-- Date: 2012-07-21 Sat -->
<!-- DocBook XML file generated by Org-mode 7.8.09 Emacs 24 -->
<article xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
  <title>Tutorial: An Efficient Algorithm for Easy-First Non-Directional Dependency Parsing -- writing the code</title>
  <info>
    <author>
      <personname>
        <firstname>Aviad</firstname> <othername></othername> <surname>Reich</surname>
      </personname>
      
    </author>
  </info>
<section xml:id="sec-1">
<title>How to contribute to this document</title>
<section xml:id="sec-1_1">
<title>All formats</title>
<para>   This document exists in XHTML, latex, text and org-mode
   versions. Editing the first three is straightforward, but will force
   all future contributors (if such will exist) to use the same
   version/format, since this will break the compatibility of the
   different formats. Do this only if you're sure the future contributors
   will be OK with it, or you know they will not exist (for example: you
   are now completing the document). If you have done so, be sure to
   either label the other versions as outdated/irrelevant, or simply
   delete them.
</para>
</section>

<section xml:id="sec-1_2">
<title>OPTION: Using Emacs' org-mode</title>
<para>   Another option is to edit the text file 'tutorial.org' in you favorite
   text editor. If you ignore lines 5-15, it's pretty much
   straightforward to understand the usage: 
   The number of left-aligned '*' before a line determine it's `depth' in
   the document (more is deeper), and elements are automatically nested in
   the immediate higher level item. 
</para>

<para>
   if you want $\TeX{}$, or $\LaTeX$,
   include its code inside adjacent dollar signs: \\
   <code>$[latex code here]$</code>.
   Just look at 'tutorial.org' for examples.
</para>

<para>
   To use the other many wonderful, yet simple to use, features of
   org-mode, like auto-numbering of items, footnotes and others, 
   it's recommended you read the <link xlink:href="http://orgmode.org/">orgmode website</link> and the (relevant) <link xlink:href="http://orgmode.org/org-mode-documentation.html">docs</link>,
   or the tutorial that comes with it as part of Emacs, or <link xlink:href="http://orgmode.org/worg/org-tutorials/">these tutorials</link>.
</para>
<variablelist>
<varlistentry><term>TODOs</term><listitem>
<para>When (if..) you complete an item that is marked as a red
             'TODO', just delete the word 'TODO' from the <code>org</code>
             file. Once a whole section is done, delete the topmost
             'TODO', and the '[x/x]' after the section name, so they will
             no longer be displayed. You could optionally move the cursor
             to the line with a 'TODO' and press Ctrl-c Ctrl-t to mark
             that item as done (and add a timestamp).  An additional
             Ctrl-c Ctrl-t will remove the TODO altogether.
</para>
</listitem></varlistentry>
</variablelist>
<variablelist>
<varlistentry><term>Exporting</term><listitem>
<para>To export to HTML, tex and text once you're done, open
             Emacs (you  know where to get it), press Ctrl-x Ctrl-f
             and type the path to the file. Then, press Ctrl-c
             Ctrl-e h (for HTML), Ctrl-c Ctrl-e p (for pdf), Ctrl-c
             Ctrl-e l (for latex), Ctrl-c Ctrl-e u (for unicode
             text, a for ascii). Many other export format exist -
             you'll find it in the ``Emacs-style popup''
             window. \\
             <emphasis role="bold">MAKE SURE YOU EXPORT IN ALL FORMATS ONCE YOU'RE              DONE, SO COMPATIBILITY IS MAINTAINED.</emphasis> 
</para>
</listitem></varlistentry>
</variablelist>
<para>
As this is written (August 2012), I care about this document, and
would be happy to extend my help if it's wanted. To email me use the
first 3 letters of `Aviad', followed by a dot ('.') and the
first 3 of `Reich'. Then mail me at: <code>[what-you-got]@gmail.com</code>.
</para>

<para>
Additionally, there is a github repo:
<link xlink:href="https://github.com/lxmonk/NLP12-Easyfirst_tutorial">https://github.com/lxmonk/NLP12-Easyfirst_tutorial</link>, that you can clone
or fork. If you do, and you've created a new one - change this
address. Otherwise, let me know and I'll update.
</para>
</section>
</section>

<section xml:id="sec-2">
<title>[TODO] An intro to dep parsing [0/3]</title>
<section xml:id="sec-2_1">
<title>[TODO] Formats of the data</title>
<para></para>
</section>

<section xml:id="sec-2_2">
<title>[TODO] Example sentences</title>
<para></para>
</section>

<section xml:id="sec-2_3">
<title>[TODO] Rendering of trees in text and graphically</title>
<para></para>
</section>
</section>

<section xml:id="sec-3">
<title>[TODO] Intro to dep parsing using transition based parsing [0/2]</title>
<section xml:id="sec-3_1">
<title>[TODO] How shift reduce works</title>
<para></para>
</section>

<section xml:id="sec-3_2">
<title>[TODO] Turning a tree into a sequence of shift reduce transitions</title>
<para></para>
</section>
</section>

<section xml:id="sec-4">
<title>[TODO] Malt like parsing [0/2]</title>
<section xml:id="sec-4_1">
<title>[TODO] Training a classifier to learn which transition is best at each step</title>
<para></para>
</section>

<section xml:id="sec-4_2">
<title>[TODO] Typical features used for malt</title>
<para></para>
</section>
</section>

<section xml:id="sec-5">
<title>[TODO] Evaluation methods for dep parsing</title>
<para></para>
</section>

<section xml:id="sec-6">
<title>[TODO] Evaluation of a demo malt parser</title>
<para></para>
</section>

<section xml:id="sec-7">
<title>Easy First</title>
<section xml:id="sec-7_1">
<title>Read the paper</title>
<para>
The article: \\
<emphasis role="bold">Easy First Dependency Parsing of Modern Hebrew</emphasis>, \\
   Yoav Goldberg and Michael Elhadad, \\
   <emphasis>SPMRL 2010 (NAACL Workshop on Statistical Parsing of    Morphologically-rich Languages)</emphasis>
</para>
<para>
It can be obtained from <link xlink:href="http://www.cs.bgu.ac.il/~yoavg/publications/naacl2010dep.pdf">Yoav Goldberg's BGU webpage</link>, or at the acm
website: 
<link xlink:href="http://dl.acm.org/citation.cfm?id=1857999.1858114">http://dl.acm.org/citation.cfm?id=1857999.1858114</link>.
</para>
</section>

<section xml:id="sec-7_2">
<title>Quiz on the paper</title>
<section xml:id="sec-7_2_1">
<title>Introduction and Easy-First</title>
<orderedlist>
<listitem>
<para>From the article (pg. 1): \\
     "Current dependency parsers can be categorized
     into three families: <emphasis role="bold">local-and-greedy transition-based parsers</emphasis>
     (e.g., MALTPARSER (Nivre et al., 
     2006)), <emphasis role="bold">globally optimized graph-based parsers</emphasis>
     (e.g., MST P ARSER (McDonald et al., 2005)), and
     <emphasis role="bold">hybrid systems</emphasis> (e.g., (Sagae and Lavie, 2006b;
     Nivre and McDonald, 2008)), which combine the
     output of various parsers into a new and improved
     parse, and <emphasis role="bold">which are orthogonal to our approach</emphasis>."  (no emphasis   
   in the original text) \\
   <emphasis role="underline">Who is orthogonal to the authors' approach? Why?</emphasis> \\
</para>
<variablelist>
<varlistentry><term>a</term><listitem>
<para>Local-and-greedy transition-based parsers
</para>
</listitem></varlistentry>
<varlistentry><term>b</term><listitem>
<para>Globally optimized graph-based parsers
</para>
</listitem></varlistentry>
<varlistentry><term>c</term><listitem>
<para>Hybrid systems
</para>
</listitem></varlistentry>
<varlistentry><term>d</term><listitem>
<para>All of the above
</para>
</listitem></varlistentry>
<varlistentry><term>e</term><listitem>
<para>None of the above
</para>
</listitem></varlistentry>
</variablelist>
</listitem>
<listitem>
<para>According to the article, what are the shortcomings of
   transition-based parsers? Which of these have been addressed by the
   easy-first parser? How?
</para>
</listitem>
<listitem>
<para>One might claim that transition-based parsers suffer from an
   imbalance, in relation to the knowledge they have about the
   sentence as it's being parsed. How might easy-first help to mend
   this? 
</para>
</listitem>
<listitem>
<para>Why are transition-based parsers often restricted to only a limited
   look-ahead window? 
</para>
</listitem>
<listitem>
<para>When will we prefer a globally optimized graph-based parser over a
   transition-based parser? When would a transition-based one be more
   appropriate? 
</para>
</listitem>
<listitem>
<para>The article states that easy-first is a greedy algorithm. What are
   the benefits of this fact? 
</para>
</listitem>
<listitem>
<para>How are transition-based parsers different than humans when
   dependency-parsing a sentence? 
</para>
</listitem>
<listitem>
<para>Do humans annotate a sentence in a way similar to graph-based
   parsers? 
</para>
</listitem>
<listitem>
<para>Of the three parser classes (transition, graph-based and
   easy-first), which is the most similar to a human's way of
   annotating a sentence? 
</para>
</listitem>
<listitem>
<para>In your opinion, is being similar to the human way of parsing a
    sentence a positive or a negative approach to the problem? Why?
</para>
</listitem>
</orderedlist>
</section>

<section xml:id="sec-7_2_2">
<title>Parsing Algorithm</title>
<orderedlist>
<listitem>
<para>Look at figure 1 in the article. In each step, how is the action
    to be performed chosen?
</para>
</listitem>
<listitem>
<para>In step 1 (figure 1), if the bold number <emphasis role="bold">403</emphasis> was instead 136,
   what action would have been performed? 
</para>
</listitem>
<listitem>
<para>What is the range of values for the arc "brown --&gt; fox", assuming
   all others remain unchanged, that will lead to the same parse tree?
   What is the range for the arcs "a --&gt; brown" and "joy --&gt; with"
   that will lead to the same parse tree?
</para>
</listitem>
<listitem>
<para>Assuming the <emphasis role="bold">difficulty</emphasis> of choosing an action is measured by the
   difference between the two highest arc's score. On which step was
   making this decision hardest? Can you "feel" this difficulty trying
   to parse the sentence yourself?
</para>
</listitem>
<listitem>
<para>Algorithm 1.1 is identical to algorithm 1 (see below), but in it, line 3 is <emphasis role="bold">changed</emphasis> to
   $pending = p_{1} \ldots p_{n-1} &larr; w_{1} \ldots w_{n-1}$.
   What will be the first step in parsing the sentence "a brown fox
   jumped with joy" in which the two algorithms will diverge? (hint:
   use figure 1) 
   In general, what will this change cause? \\
   <mediaobject>
<imageobject>
<imagedata fileref="images/Algorithm1.png"  align="center" valign="middle"/>
</imageobject>
</mediaobject>]] \\
</para>
</listitem>
<listitem>
<para>What does the function EdgeFor do? How?
</para>
</listitem>
<listitem>
<para>Write the loop from line 5 in python.
</para>
</listitem>
<listitem>
<para>Can you find this loop in the file <link linkend="sec-9-1">easyfirst.py</link>? \\
</para>
<variablelist>
<varlistentry><term>hint 1</term><listitem>
<para>the variables in lines 174,175 are never used, and can
               be safely removed from the <code>train</code> function).\\ 
</para>
</listitem></varlistentry>
<varlistentry><term>hint 2</term><listitem>
<para><code>In [1]: zip(range(10), range(10)[1:])</code> \\ 
               <code>Out[1]: [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)]</code>
</para>
</listitem></varlistentry>
</variablelist>
</listitem>
<listitem>
<para>In line 5, where is $score(act(i))$ taken from?
</para>
</listitem>
</orderedlist>
</section>

<section xml:id="sec-7_2_3">
<title>Learning Algorithm and Feature Representation</title>
<para>    see <link linkend="sec-7-2-5">Perceptron Classifier</link>
</para>
</section>

<section xml:id="sec-7_2_4">
<title>Computational Complexity and Efficient Implementation</title>
<orderedlist>
<listitem>
<para>From the article (pg. 5): \\
   "The parsing algorithm (Algorithm 1) begins with
   $n + 1$ disjoint structures (the words of the sentence +
   ROOT symbol), and terminates with one connected
   structure. Each iteration of the main loop connects
   two structures and removes one of them, and so the
   loop repeats for exactly $n$ times.
   The $argmax$ in line 5 selects the maximal scoring
   action/location pair. At iteration $i$, there are $n - 1$
   locations to choose from, and a naive computation of
   the $argmax$ is $O(n)$, resulting in an $O(n^{2})$ algorithm."\\
   Is the algorithm really $O(n^{2})$? \\
   <emphasis role="bold">Why? What is the non-naive computation?</emphasis>
</para>
</listitem>
<listitem>
<para>From the article (pg. 5: footnote 4): \\
   "Indeed, in our implementation we do not use a heap, and
   opt instead to find the argmax using a simple O(n) max
   operation. This $O(n^2)$ algorithm is faster in practice than the heap 
   based one, as both are dominated by the $O(n)$ feature extraction,
   while the cost of the $O(n)$ max calculation is negligible 
   compared to the constants involved in heap maintenance." \\
   <emphasis role="bold">a) What should have been the complexity using the heap?</emphasis> \\
   <emphasis role="bold">b) Can you think of a situation in which a heap should be used in the    implementation?</emphasis>
</para>
</listitem>
<listitem>
<para>Beam search parsers are only mentioned in Table 1 in the
   article, and the quoted article was published 2 years prior. Do you
   think this might imply at the identity of the identity of the
   editor/reviewers of the NAACL article (this one)? :)
</para>
</listitem>
</orderedlist>
</section>

<section xml:id="sec-7_2_5">
<title>[TODO] <anchor xml:id="Perceptron-Classifier"/></title>
<para></para>
</section>

<section xml:id="sec-7_2_6">
<title><anchor xml:id="Cython"/></title>
<orderedlist>
<listitem>
<para>First, if you are not yet familiar with <link xlink:href="http://cython.org">Cython</link>, it's highly
      recommended you read the <link xlink:href="http://docs.cython.org/">docs</link> first, or minimally (and
      reasonably) <link xlink:href="http://conference.scipy.org/proceedings/SciPy2009/paper_1/full_text.pdf">the tutorial (pdf)</link>. A <emphasis>very</emphasis> minimal <link linkend="sec-8">Cython Primer</link> is given
      below.
</para>
</listitem>
<listitem>
<para>In the file <link linkend="sec-9-2">ml.pyx</link> below, what classes are created?
</para>
</listitem>
<listitem>
<para>Which of them are python-only? Why?
</para>
</listitem>
<listitem>
<para>There are several "data" classes: <code>DoublesArr</code>,
      <code>MulticlassModel</code>, <code>MulticlassParamData</code>, <code>MultitronParameters</code>,
      <code>ParamData</code>, <code>PerceptronParameters</code>. What is each of them used for?
</para>
</listitem>
<listitem>
<para>Where in the code is the Perceptron initialized? What are the
      initial values?
</para>
</listitem>
<listitem>
<para>Where is the learning (adjustment of parameters) happening?
</para>
</listitem>
<listitem>
<para>In line 518, the <code>score</code> function is defined. Follow the code,
      and answer these questions:
      a) How is the score calculated?
      b) When will the <code>except</code> clause (lines 528-529) be executed?
      c) Can you re-write the function using a functional (rather than
      the current imperative) style?
</para>
</listitem>
</orderedlist>
</section>
</section>
</section>

<section xml:id="sec-8">
<title><anchor xml:id="Cython-Primer"/></title>
<para>    From <link xlink:href="https://en.wikipedia.org/wiki/Cython">Wikipedia</link>: \\
    "Cython is a programming language to simplify writing C and C++
    extension modules for the CPython Python runtime.<footnote xml:id="fn-1"><para>DEFINITION NOT FOUND: 3</para></footnote> Strictly
    speaking, Cython syntax is a superset of Python syntax
    additionally supporting: 
</para>
<itemizedlist>
<listitem>
<para>Direct calling of C functions, or C++ functions/methods, from Cython code.
</para>
</listitem>
<listitem>
<para>Strong typing of Cython variables, classes, and class attributes
      as C types. 
</para>
</listitem>
</itemizedlist>
<para>    Cython compiles to C or C++ code rather than Python, and the
    result is used as a Python Extension Module or as a stand-alone
    application embedding the CPython runtime."
</para>

<para>
    The importance of Cython in the implementation of the easy-first
    algorithm, is that it allows a fast and optimized version of
    python to be executed. This is not an accurate statement, but it
    suffices for this paper.
</para>

<para>
    The Cython code, is used to create the <code>ml</code> module, and is found
    in the file <code>ml.pyx</code>. This file is <emphasis role="bold">compiled</emphasis> to the file <code>ml.c</code>,
    but for clarity, read the <code>.pyx</code> file, not the C one.
</para>

<para>
    If you have not read any of the links above, here is the bare
    minimum you need to know in order to read <code>ml.pyx</code>: 
</para>
<orderedlist>
<listitem>
<para><code>cimport</code> means 'import from a C library.'
</para>
</listitem>
<listitem>
<para><code>cdef</code> means 'define in C -- usually it'll be a function, a
       (python) class, or a variable definition, and will have a type.'
</para>
</listitem>
<listitem>
<para>Types are declared. To declare (for example) a pointer to a
       double, either <code>cdef double* double_ptr</code> or <code>&lt;double *&gt;        func(args)</code> is used.
</para>
</listitem>
<listitem>
<para><code>cpdef</code> means 'this is defined in a way that will be accessible
       from both python and c.' In order to define a python-only
       function, the usual <code>def</code> applies.
</para>
</listitem>
<listitem>
<para>A return type is declared for C functions. For example, \\
       <code>cpdef object get_scores(self,list features):</code> (taken from <code>ml.pyx</code> line 133) means: the
       function <code>get_scores</code> is defined in both python and C. it will
       <emphasis role="bold">return an object</emphasis>, and will receive a <code>python list</code> type bound
       to the <code>features</code> variable. As in python, <code>self</code> means it's a method
</para>
</listitem>
<listitem>
<para><code>__cinit__</code> is the class constructor (python's <code>__init__</code>) when
       executed from C. Think of it as <code>__init__</code>.
</para>
</listitem>
<listitem>
<para><code>__dealloc__</code> is the class destructor.
</para>
</listitem>
</orderedlist>
</section>

<section xml:id="sec-9">
<title>Code</title>
<section xml:id="sec-9_1">
<title><anchor xml:id="easyfirst.py"/>:</title>
<para><link xlink:href="https://gist.github.com/3467275">https://gist.github.com/3467275</link>
</para>
</section>

<section xml:id="sec-9_2">
<title><anchor xml:id="ml.pyx"/>:</title>
<para><link xlink:href="https://gist.github.com/3566683">https://gist.github.com/3566683</link>
</para>
</section>
</section>
</article>
